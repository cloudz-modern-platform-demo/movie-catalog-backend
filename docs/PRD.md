# 영화 카탈로그 백엔드 PRD

## 1. 제품 개요
- 지역 영화관이 보유한 영화 정보를 한 곳에서 확인하고 관리할 수 있는 백엔드 API.
- 경량 RDB(SQLite) 파일 데이터베이스로 데이터를 관리하여 배포/운영 단순화.

## 2. 주요 사용자
1. **영화관 본사/지점 관리자**: 지점 정보와 상영 중인 영화 정보를 CRUD로 관리.
2. **내부 운영 도구**: 관리자 포털, 배치 작업 등 백엔드 API를 호출하여 현황을 조회.

## 3. 핵심 기능
1. 영화관(Theater) CRUD: 이름, 브랜드, 위치, 운영시간 관리.
2. 영화(Movie) CRUD: 제목, 배급사, 장르, 상영시간(분), 티켓 가격, 상영 영화관 연동.
3. 영화관별 영화 목록: 특정 영화관에서 상영 중인 영화 리스트 제공.
4. 데이터 저장소: `data/movie_catalog.db` SQLite 파일을 단일 데이터 소스로 사용.
5. 스키마 제약: `ticket_price`는 원 단위 정수로 저장하며 음수가 될 수 없다.
6. 동일 영화(동일 `title`)라도 영화관별로 가격이 다를 수 있으며, 각 상영(레코드) 단위로 `ticket_price`를 관리한다.

## 4. 요구 사항
- 모든 API는 FastAPI 기반 REST 인터페이스.
- 저장소는 SQLite 기반으로 트랜잭션 무결성과 동시성 안전성을 제공해야 함.
- 영화 생성/수정 시 반드시 유효한 영화관 ID가 필요.
- 영화관 삭제 시 연결된 영화가 있으면 삭제 차단.
- 데이터 타입은 RDB 스키마 제약을 따른다. `ticket_price`는 정수 타입만 허용(소수점 불가).
- 동일 영화 제목이 여러 영화관에서 상영될 수 있으며, 영화관별로 `ticket_price`가 상이할 수 있다(중복 제목 허용).
- 에러는 HTTP status + `{"detail": str}` 형태 메시지로 응답.
- 삭제 성공 시 HTTP `204 No Content`로 응답하며 응답 바디는 포함하지 않음(FastAPI 제약 준수).
- 초기 데이터 마이그레이션(앱 시작 시 DB가 비어있을 때 1회 수행):
  - 우선순위 1: 프로젝트 루트 `data/theaters.json`, `data/movies.json`을 읽어 DB에 마이그레이션
  - 우선순위 2: JSON이 없으면 내장 샘플 데이터(8.1/8.2)로 시드
  - JSON 포맷 제약:
    - 최상위는 배열
    - Theater: `id? (UUID4)`, `name`, `brand`, `location`, `operating_hours`
    - Movie: `id? (UUID4)`, `title`, `distributor`, `ticket_price (int>=0)`, `runtime_minutes (int>=0)`, `genre`, `theater_id (existing)`
    - `id`가 없으면 서버가 UUID4를 자동 생성
  - 검증/오류 처리:
    - 구조적 오류(JSON 파싱 실패, 최상위 타입 불일치)는 마이그레이션 실패로 간주
    - 레코드 단위 검증 실패는 해당 레코드만 건너뛰고 계속 진행(최소 1건 이상 성공 시 성공으로 간주)
    - 존재하지 않는 `theater_id`를 참조하는 영화 레코드는 건너뜀(로그 남김)
  - 중복 삽입 방지: DB가 비어있을 때만 수행
  - 재시도: JSON을 수정한 뒤 앱 재시작으로 재시도 가능
  - 부분 백필: DB에 극장은 있으나 영화가 없을 경우, 재시작 시 영화만 자동 백필 수행

### 4.1 초기화/복구 가이드(다음 개발 위한 명시)
- DB 초기화 동작
  - 앱 시작 시 DB가 비어있으면 시드/마이그레이션을 정확히 1회 수행한다.
  - 우선순위: `data/*.json` → 내장 샘플 데이터(예시 8.1/8.2).
  - 구조적 오류(JSON 파싱 실패·최상위 타입 오류)는 해당 경로를 전체 실패로 간주하고 내장 샘플로 폴백한다.
  - 레코드 단위 오류는 스킵하며, 최소 1건 이상 성공 시 커밋한다. 전부 실패한 경우 롤백한다.
  - 참조 무결성: `Movie.theater_id`는 DB에 존재하는 `Theater.id`만 허용한다. 미존재 참조 레코드는 스킵한다.
  - 부분 백필 동작: DB에 `Theater`는 존재하나 `Movie`가 비어있으면, 앱 시작 시 영화만 자동 백필한다(삭제·초기화 없이 복구).
- 운영 복구
  - 시작 단계에서 DB 손상 등으로 앱이 기동 실패할 경우 `data/movie_catalog.db`를 삭제 후 재기동하면 자동으로 재생성·시드된다.
  - 영화 데이터만 누락된 경우에는 DB 삭제 없이 재기동만으로 영화가 자동 백필된다.
  - 성공 기준: 재기동 후 `/theaters/`, `/movies/` 조회 시 1건 이상 레코드가 반환되면 정상으로 간주한다.
- 수용 기준(빠른 점검 체크리스트)
  - GET `/theaters/` 호출 시 5±2개 시드 항목이 반환된다.
  - GET `/movies/` 호출 시 최소 1건 이상 반환되며, `theater_id` 필터로 교차 검증 가능하다.
  - DELETE `/theaters/{id}`는 연결된 영화가 있을 경우 409를 반환한다.
  - DELETE 성공 시 응답은 204이며 바디가 없다.
  - 스타트업 시 시드 단계에서 단일 컬럼 조회 처리 규약 준수로 언팩/스칼라 관련 예외(ValueError/AttributeError) 미발생.

#### 4.1.1 오류 예방 규약(시드/ORM 결과 처리)
- ORM 단일 컬럼 조회는 스칼라 시퀀스로 취급한다. 예: `session.exec(select(Theater.id)).all()` 결과를 그대로 사용하고, 튜플 언팩(`for (tid,) in ...`)은 금지.
- SQLModel/SQLAlchemy 조합에서 `.scalars()` 호출이 불필요/미지원일 수 있으므로 사용하지 않는다. 안전 패턴: `result = session.exec(select(Model.id)); ids = set(result.all())`.
- Pydantic v2 사용 규약: 입력/수정 데이터 직렬화 시 `.model_dump()`를 사용한다(`.model_dict()` 금지).
- DetachedInstanceError 방지: 서비스 계층은 세션 종료 전에 SQLModel 엔티티를 스키마 객체(TheaterRead/MovieRead)로 변환하여 반환한다. 세션 종료 후 엔티티 속성 접근 금지. 헬퍼 함수 패턴(`_entity_to_dict()`) 사용 권장.

## 5. 사용자 시나리오
1. **지점 등록**: 운영팀이 신규 지점을 생성하고 기본 정보(브랜드, 위치, 운영시간)를 저장.
2. **상영작 편성**: 지점 관리자가 영화 데이터를 등록하고 티켓 가격, 상영 시간, 장르를 입력.
3. **편성 변경**: 영화 정보를 수정하거나 상영 종료 시 삭제.
4. **현황 대시보드**: 내부 도구가 영화관/영화 목록 API를 호출하여 최신 정보를 표시.

## 6. 성공 지표
- CRUD API 호출 성공률 99% 이상.
- JSON 파일 손상/경쟁 상태 없이 누락 데이터 0건.
- 영화관/영화 생성 이후 조회 API 응답시간 200ms 미만(로컬 기준) 유지.

## 6.1 API 문서(FASTAPI Swagger/Redoc)
- Swagger UI: `http://localhost:8000/docs`
- ReDoc: `http://localhost:8000/redoc`
- OpenAPI: `http://localhost:8000/openapi.json`
- 실행 방법(로컬):
  - `uv run movie-catalog-backend`
  - 환경변수(옵션): `HOST`(기본 0.0.0.0), `RELOAD`(true/false), `DATABASE_URL` (포트는 8000 고정, `PORT`는 무시)

## 7. 범위 및 제외
- **포함**: SQLite 기반 영속성, FastAPI CRUD, 간단한 관계 검증.
- **제외**: 인증/권한, 통계/보고서, 멀티 리전 배포, 실시간 편성 동기화.

## 8. 초기 샘플 데이터
개발/로컬 테스트 편의를 위해 초기 샘플 데이터는 앱 시작 시 DB가 비어있는 경우 자동으로 SQLite DB(`data/movie_catalog.db`)에 시드된다. `data/*.json` 파일을 사용한다.